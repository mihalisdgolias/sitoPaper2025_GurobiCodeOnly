# This script analyzes the data generated by nTerminalDataGenerationLatest.py.
#
# IMPORTANT: This script requires the 'generated_data' subfolder to exist,
# which is populated with .pkl files by 'nTerminalDataGenerationLatest.py'
# (Option 1 or 3). You must run that script first.

import numpy as np
import pandas as pd
import os
from typing import List, Tuple, Dict, Any, Optional
import matplotlib.pyplot as plt
import pickle
import re

# =============================================================================
# MAIN PARAMETERS
# =============================================================================
DATA_FOLDER = 'generated_data'
OUTPUT_SUBFOLDER = 'datagenValidation'
OUTPUT_FILE = os.path.join(OUTPUT_SUBFOLDER, 'full_optimization_analysis.xlsx')
PLOT_OUTPUT_FOLDER = os.path.join(OUTPUT_SUBFOLDER, 'terminal_plots')
FIXED_MC_MIN = 80.0

# =============================================================================
# OPTIMIZED TERMINAL MODEL - COPIED FOR FUNCTIONALITY
# =============================================================================

class OptimizedTerminalModel:
    def __init__(self, revenue_params, cost_params, capacity):
        self.a, self.b, self.c = revenue_params
        self.mc_start, self.mc_min, self.u_optimal, self.slope1, self.slope2 = cost_params
        self.capacity = capacity

    def revenue_per_container(self, u):
        return self.a * u + self.b

    def marginal_revenue(self, u):
        u = np.asarray(u)
        return 2 * self.a * u + self.b

    def marginal_cost(self, u):
        u = np.asarray(u)
        mc = np.where(u <= self.u_optimal,
                      self.mc_start - self.slope1 * u,
                      self.mc_min + self.slope2 * (u - self.u_optimal))
        return mc

    def total_cost(self, u):
        u = np.asarray(u)
        costs = np.zeros_like(u, dtype=float)
        mask1 = (u > 0) & (u <= self.u_optimal)
        costs[mask1] = self.mc_start * u[mask1] - 0.5 * self.slope1 * u[mask1] ** 2
        mask2 = u > self.u_optimal
        if np.any(mask2):
            cost_at_optimal = self.mc_start * self.u_optimal - 0.5 * self.slope1 * self.u_optimal ** 2
            costs[mask2] = cost_at_optimal + self.mc_min * (u[mask2] - self.u_optimal) + 0.5 * self.slope2 * (
                    u[mask2] - self.u_optimal) ** 2

        return costs * self.capacity

    def average_cost_per_container(self, u):
        u = np.asarray(u)
        u_safe = np.where(u > 0, u, 1e-10)
        integral_costs = np.zeros_like(u, dtype=float)
        mask1 = (u > 0) & (u <= self.u_optimal)
        integral_costs[mask1] = self.mc_start * u[mask1] - 0.5 * self.slope1 * u[mask1] ** 2
        mask2 = u > self.u_optimal
        if np.any(mask2):
            cost_at_optimal = self.mc_start * self.u_optimal - 0.5 * self.slope1 * self.u_optimal ** 2
            integral_costs[mask2] = cost_at_optimal + self.mc_min * (u[mask2] - self.u_optimal) + 0.5 * self.slope2 * (
                    u[mask2] - self.u_optimal) ** 2
        return integral_costs / u_safe

    def profit_per_container(self, u):
        return self.revenue_per_container(u) - self.average_cost_per_container(u)

    def marginal_profit(self, u):
        return self.marginal_revenue(u) - self.marginal_cost(u)


def analyze_generated_data_from_folder(data_folder: str) -> pd.DataFrame:
    """
    Reads all .pkl files from a folder, analyzes the terminal parameters,
    and returns a summary DataFrame.
    """
    results_list = []

    if not os.path.exists(data_folder):
        print(f"Error: The folder '{data_folder}' was not found.")
        return pd.DataFrame()

    data_files = [f for f in os.listdir(data_folder) if f.endswith('.pkl')]
    if not data_files:
        print(f"Error: No .pkl files found in '{data_folder}'.")
        return pd.DataFrame()

    filename_pattern = re.compile(r'data_T(\d+)_subset_([\d_]+)_CI(\d+)_instance_(\d+)\.pkl')

    for filename in data_files:
        filepath = os.path.join(data_folder, filename)

        try:
            with open(filepath, 'rb') as f:
                data = pickle.load(f)
        except Exception as e:
            print(f"Error loading file {filename}: {e}. Skipping.")
            continue

        match = filename_pattern.match(filename)
        if not match:
            print(f"Warning: Filename '{filename}' does not match the expected pattern. Skipping.")
            continue

        # CORRECTED: Extract all groups from the filename match
        num_terminals_str, subset_str, ci_rate_str, instance_idx_str = match.groups()

        num_terminals = int(num_terminals_str)
        subset_composition = subset_str
        ci_rate = int(ci_rate_str) / 100.0
        instance_index = int(instance_idx_str)

        input_data = data['inputData'][0]

        for i in range(num_terminals):
            # FIXED: Correct the parameter order and revenue slope sign.
            # a_revenue is saved as -a, so we must negate it again to get the correct 'a' value.
            revenue_params = (-input_data[i, 6], input_data[i, 5], 0)
            # The cost params are: mc_start, mc_min, u_optimal, slope1, slope2.
            # mc_min is a fixed constant, not part of the input_data array.
            cost_params = (input_data[i, 1], FIXED_MC_MIN, input_data[i, 4], input_data[i, 2], input_data[i, 3])
            capacity = input_data[i, 0]

            terminal = OptimizedTerminalModel(revenue_params, cost_params, capacity)

            u_range = np.linspace(0.01, 0.99, 1000)
            total_revenue_curve = terminal.revenue_per_container(u_range) * u_range * terminal.capacity
            total_cost_curve = terminal.total_cost(u_range)
            total_profit_curve = total_revenue_curve - total_cost_curve

            max_profit_idx = np.argmax(total_profit_curve)
            optimal_profit_vc = u_range[max_profit_idx]
            max_revenue_idx = np.argmax(total_revenue_curve)
            optimal_revenue_vc = u_range[max_revenue_idx]

            # CORRECTED: Added all the parsed metadata and reconstructed terminal parameters
            results_list.append({
                'Filename': filename,
                'Num_Terminals': num_terminals,
                'Subset_Composition': subset_composition,
                'CI_Rate_Data': ci_rate,
                'Instance_Index': instance_index,
                'Terminal_ID': i + 1,
                'Optimal_Profit_VC_Ratio': optimal_profit_vc,
                'Max_Total_Profit ($)': total_profit_curve[max_profit_idx],
                'Optimal_Revenue_VC_Ratio': optimal_revenue_vc,
                'Max_Total_Revenue ($)': total_revenue_curve[max_revenue_idx],
                'VC_Ratio_Difference': optimal_revenue_vc - optimal_profit_vc,
                'a_revenue': terminal.a,
                'b_revenue': terminal.b,
                'c_revenue': terminal.c,
                'mc_start': terminal.mc_start,
                'mc_min': terminal.mc_min,
                'u_optimal': terminal.u_optimal,
                'slope1': terminal.slope1,
                'slope2': terminal.slope2,
                'Capacity': terminal.capacity
            })

    return pd.DataFrame(results_list)


def plot_terminal_functions(results_df: pd.DataFrame):
    """
    Generates and saves plots for revenue, cost, and profit functions for each terminal.
    """
    if results_df.empty:
        print("No terminal data to plot.")
        return

    os.makedirs(PLOT_OUTPUT_FOLDER, exist_ok=True)
    print(f"Created plotting output folder: {PLOT_OUTPUT_FOLDER}")

    u_range = np.linspace(0.01, 0.99, 1000)

    # To avoid generating too many plots, let's just plot a sample
    # We'll plot one terminal from each unique combination of Num_Terminals, Subset, and CI_Rate
    # FIX: Use .reset_index() to convert groupby keys back to columns
    unique_terminals_to_plot = results_df.groupby(['Num_Terminals', 'Subset_Composition', 'CI_Rate_Data']).first().reset_index()

    for _, row in unique_terminals_to_plot.iterrows():
        revenue_params = (row['a_revenue'], row['b_revenue'], row['c_revenue'])
        cost_params = (row['mc_start'], row['mc_min'], row['u_optimal'], row['slope1'], row['slope2'])
        capacity = row['Capacity']
        terminal = OptimizedTerminalModel(revenue_params, cost_params, capacity)

        terminal_name = f"T{int(row['Num_Terminals'])}_{row['Subset_Composition']}_CI{int(row['CI_Rate_Data'] * 100)}_Inst{int(row['Instance_Index'])}_Term{int(row['Terminal_ID'])}"
        optimal_profit_vc = row['Optimal_Profit_VC_Ratio']

        total_revenue_curve = terminal.revenue_per_container(u_range) * u_range * terminal.capacity
        total_cost_curve = terminal.total_cost(u_range)
        total_profit_curve = total_revenue_curve - total_cost_curve

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(u_range, total_revenue_curve, label='Total Revenue', color='green', linewidth=2)
        ax.plot(u_range, total_cost_curve, label='Total Cost', color='red', linewidth=2)
        ax.plot(u_range, total_profit_curve, label='Total Profit', color='blue', linewidth=2)

        ax.axvline(x=optimal_profit_vc, color='black', linestyle='--',
                   label=f'Optimal V/C Ratio ({optimal_profit_vc:.2%})')

        ax.set_title(f'Revenue, Cost, and Profit Functions for {terminal_name}')
        ax.set_xlabel('V/C Ratio (Utilization)')
        ax.set_ylabel('Total Value ($)')
        ax.grid(True, linestyle='--', alpha=0.6)
        ax.legend()

        plt.tight_layout()

        plot_path = os.path.join(PLOT_OUTPUT_FOLDER, f'{terminal_name}_functions.png')
        plt.savefig(plot_path, dpi=300)
        plt.close(fig)
        print(f"Plot saved for {terminal_name} to '{plot_path}'")


def save_analysis_to_excel(results_df: pd.DataFrame, sheet_name: str):
    """
    Saves the analysis results to a new Excel file.
    """
    if results_df.empty:
        print("No results to save.")
        return

    os.makedirs(OUTPUT_SUBFOLDER, exist_ok=True)

    try:
        with pd.ExcelWriter(OUTPUT_FILE, engine='openpyxl') as writer:
            results_df.to_excel(writer, sheet_name=sheet_name, index=False)
        print(f"\nAnalysis results saved to '{OUTPUT_FILE}' in sheet '{sheet_name}'.")
    except Exception as e:
        print(f"\nError saving to Excel: {e}")


def print_analysis_table(results_df: pd.DataFrame, title: str):
    """
    Prints a formatted summary table of the analysis results to the console.
    """
    if results_df.empty:
        print("No results to display.")
        return

    print("\n" + "=" * 135)
    print(f"{title}")
    print("=" * 135)

    print(results_df.head().to_string())
    print("\n...")
    print(results_df.tail().to_string())

    print("=" * 135)


if __name__ == "__main__":
    os.makedirs(OUTPUT_SUBFOLDER, exist_ok=True)
    print("=" * 60)
    print("MASTER ANALYSIS SCRIPT")
    print("=" * 60)

    print("\n" + "=" * 60)
    print("FULL OPTIMIZATION ANALYSIS")
    print("=" * 60)

    full_optimization_results = analyze_generated_data_from_folder(DATA_FOLDER)

    if not full_optimization_results.empty:
        print_analysis_table(full_optimization_results, "FULL OPTIMIZATION RESULTS")
        plot_terminal_functions(full_optimization_results)
        save_analysis_to_excel(full_optimization_results, 'Full_Optimization_Analysis')
    else:
        print("Skipping full optimization analysis due to missing or unreadable data.")

    print("\nAnalysis process complete.")
    print("=" * 60)