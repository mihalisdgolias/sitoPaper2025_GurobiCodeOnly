# This script analyzes the data generated by nTerminalDataGenerationLatest.py.
# MODIFIED VERSION: Creates individual terminal plots and filters for CI rate = 0 only
#
# IMPORTANT: This script requires the 'generated_data' subfolder to exist,
# which is populated with .pkl files by 'nTerminalDataGenerationLatest.py'
# (Option 1 or 3). You must run that script first.

import numpy as np
import pandas as pd
import os
from typing import List, Tuple, Dict, Any, Optional
import matplotlib.pyplot as plt
import pickle
import re

# =============================================================================
# MAIN PARAMETERS
# =============================================================================
DATA_FOLDER = 'generated_data'
OUTPUT_SUBFOLDER = 'datagenValidation'
OUTPUT_FILE = os.path.join(OUTPUT_SUBFOLDER, 'full_optimization_analysis.xlsx')
PLOT_OUTPUT_FOLDER = os.path.join(OUTPUT_SUBFOLDER, 'individual_terminal_plots')
FIXED_MC_MIN = 80.0

# NEW: Filter for CI rate = 0 only
FILTER_CI_RATE = 0.0


# =============================================================================
# OPTIMIZED TERMINAL MODEL - COPIED FOR FUNCTIONALITY
# =============================================================================

class OptimizedTerminalModel:
    def __init__(self, revenue_params, cost_params, capacity):
        self.a, self.b, self.c = revenue_params
        self.mc_start, self.mc_min, self.u_optimal, self.slope1, self.slope2 = cost_params
        self.capacity = capacity

    def revenue_per_container(self, u):
        return self.a * u + self.b

    def marginal_revenue(self, u):
        u = np.asarray(u)
        return 2 * self.a * u + self.b

    def marginal_cost(self, u):
        u = np.asarray(u)
        mc = np.where(u <= self.u_optimal,
                      self.mc_start - self.slope1 * u,
                      self.mc_min + self.slope2 * (u - self.u_optimal))
        return mc

    def total_cost(self, u):
        u = np.asarray(u)
        costs = np.zeros_like(u, dtype=float)
        mask1 = (u > 0) & (u <= self.u_optimal)
        costs[mask1] = self.mc_start * u[mask1] - 0.5 * self.slope1 * u[mask1] ** 2
        mask2 = u > self.u_optimal
        if np.any(mask2):
            cost_at_optimal = self.mc_start * self.u_optimal - 0.5 * self.slope1 * self.u_optimal ** 2
            costs[mask2] = cost_at_optimal + self.mc_min * (u[mask2] - self.u_optimal) + 0.5 * self.slope2 * (
                    u[mask2] - self.u_optimal) ** 2

        return costs * self.capacity

    def average_cost_per_container(self, u):
        u = np.asarray(u)
        u_safe = np.where(u > 0, u, 1e-10)
        integral_costs = np.zeros_like(u, dtype=float)
        mask1 = (u > 0) & (u <= self.u_optimal)
        integral_costs[mask1] = self.mc_start * u[mask1] - 0.5 * self.slope1 * u[mask1] ** 2
        mask2 = u > self.u_optimal
        if np.any(mask2):
            cost_at_optimal = self.mc_start * self.u_optimal - 0.5 * self.slope1 * self.u_optimal ** 2
            integral_costs[mask2] = cost_at_optimal + self.mc_min * (u[mask2] - self.u_optimal) + 0.5 * self.slope2 * (
                    u[mask2] - self.u_optimal) ** 2
        return integral_costs / u_safe

    def profit_per_container(self, u):
        return self.revenue_per_container(u) - self.average_cost_per_container(u)

    def marginal_profit(self, u):
        return self.marginal_revenue(u) - self.marginal_cost(u)


def analyze_generated_data_from_folder(data_folder: str) -> pd.DataFrame:
    """
    Reads all .pkl files from a folder, analyzes the terminal parameters,
    and returns a summary DataFrame filtered for CI rate = 0.
    """
    results_list = []

    if not os.path.exists(data_folder):
        print(f"Error: The folder '{data_folder}' was not found.")
        return pd.DataFrame()

    data_files = [f for f in os.listdir(data_folder) if f.endswith('.pkl')]
    if not data_files:
        print(f"Error: No .pkl files found in '{data_folder}'.")
        return pd.DataFrame()

    filename_pattern = re.compile(r'data_T(\d+)_subset_([\d_]+)_CI(\d+)_instance_(\d+)\.pkl')

    ci_zero_files_found = 0
    total_files_processed = 0

    for filename in data_files:
        filepath = os.path.join(data_folder, filename)

        try:
            with open(filepath, 'rb') as f:
                data = pickle.load(f)
        except Exception as e:
            print(f"Error loading file {filename}: {e}. Skipping.")
            continue

        match = filename_pattern.match(filename)
        if not match:
            print(f"Warning: Filename '{filename}' does not match the expected pattern. Skipping.")
            continue

        num_terminals_str, subset_str, ci_rate_str, instance_idx_str = match.groups()

        num_terminals = int(num_terminals_str)
        subset_composition = subset_str
        ci_rate = int(ci_rate_str) / 100.0
        instance_index = int(instance_idx_str)

        total_files_processed += 1

        # FILTER: Only process files with CI rate = 0
        if ci_rate != FILTER_CI_RATE:
            continue

        ci_zero_files_found += 1
        print(f"Processing CI=0 file: {filename}")

        input_data = data['inputData'][0]

        for i in range(num_terminals):
            # Correct the parameter order and revenue slope sign.
            revenue_params = (-input_data[i, 6], input_data[i, 5], 0)
            cost_params = (input_data[i, 1], FIXED_MC_MIN, input_data[i, 4], input_data[i, 2], input_data[i, 3])
            capacity = input_data[i, 0]

            terminal = OptimizedTerminalModel(revenue_params, cost_params, capacity)

            u_range = np.linspace(0.01, 0.99, 1000)
            total_revenue_curve = terminal.revenue_per_container(u_range) * u_range * terminal.capacity
            total_cost_curve = terminal.total_cost(u_range)
            total_profit_curve = total_revenue_curve - total_cost_curve

            max_profit_idx = np.argmax(total_profit_curve)
            optimal_profit_vc = u_range[max_profit_idx]
            max_revenue_idx = np.argmax(total_revenue_curve)
            optimal_revenue_vc = u_range[max_revenue_idx]

            results_list.append({
                'Filename': filename,
                'Num_Terminals': num_terminals,
                'Subset_Composition': subset_composition,
                'CI_Rate_Data': ci_rate,
                'Instance_Index': instance_index,
                'Terminal_ID': i + 1,
                'Optimal_Profit_VC_Ratio': optimal_profit_vc,
                'Max_Total_Profit ($)': total_profit_curve[max_profit_idx],
                'Optimal_Revenue_VC_Ratio': optimal_revenue_vc,
                'Max_Total_Revenue ($)': total_revenue_curve[max_revenue_idx],
                'VC_Ratio_Difference': optimal_revenue_vc - optimal_profit_vc,
                'a_revenue': terminal.a,
                'b_revenue': terminal.b,
                'c_revenue': terminal.c,
                'mc_start': terminal.mc_start,
                'mc_min': terminal.mc_min,
                'u_optimal': terminal.u_optimal,
                'slope1': terminal.slope1,
                'slope2': terminal.slope2,
                'Capacity': terminal.capacity
            })

    print(f"Filtering Summary:")
    print(f"  Total files processed: {total_files_processed}")
    print(f"  CI=0 files found: {ci_zero_files_found}")
    print(f"  Total terminals analyzed: {len(results_list)}")

    return pd.DataFrame(results_list)


def plot_individual_terminal_functions(results_df: pd.DataFrame):
    """
    Generates and saves individual plots for each terminal (CI rate = 0 only).
    """
    if results_df.empty:
        print("No terminal data to plot.")
        return

    os.makedirs(PLOT_OUTPUT_FOLDER, exist_ok=True)
    print(f"Created plotting output folder: {PLOT_OUTPUT_FOLDER}")

    u_range = np.linspace(0.01, 0.99, 1000)

    total_terminals = len(results_df)
    plots_created = 0

    print(f"Creating individual plots for {total_terminals} terminals (CI rate = 0)...")

    # Plot each terminal individually
    for _, row in results_df.iterrows():
        try:
            # Reconstruct terminal model
            revenue_params = (row['a_revenue'], row['b_revenue'], row['c_revenue'])
            cost_params = (row['mc_start'], row['mc_min'], row['u_optimal'], row['slope1'], row['slope2'])
            capacity = row['Capacity']
            terminal = OptimizedTerminalModel(revenue_params, cost_params, capacity)

            # Create descriptive terminal name
            terminal_name = (f"T{int(row['Num_Terminals'])}_{row['Subset_Composition']}_"
                             f"Inst{int(row['Instance_Index'])}_Term{int(row['Terminal_ID'])}")

            optimal_profit_vc = row['Optimal_Profit_VC_Ratio']

            # Calculate function values
            revenue_per_container_curve = terminal.revenue_per_container(u_range)
            total_revenue_curve = revenue_per_container_curve * u_range * terminal.capacity
            total_cost_curve = terminal.total_cost(u_range)
            total_profit_curve = total_revenue_curve - total_cost_curve
            marginal_cost_curve = terminal.marginal_cost(u_range)
            marginal_revenue_curve = terminal.marginal_revenue(u_range)
            average_cost_curve = terminal.average_cost_per_container(u_range)

            # Create figure with subplots
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
            fig.suptitle(f'Terminal Analysis: {terminal_name} (CI Rate = 0%)', fontsize=14, fontweight='bold')

            # Plot 1: Total Functions
            ax1.plot(u_range, total_revenue_curve, label='Total Revenue', color='green', linewidth=2)
            ax1.plot(u_range, total_cost_curve, label='Total Cost', color='red', linewidth=2)
            ax1.plot(u_range, total_profit_curve, label='Total Profit', color='blue', linewidth=2)
            ax1.axvline(x=optimal_profit_vc, color='black', linestyle='--', alpha=0.7,
                        label=f'Optimal V/C = {optimal_profit_vc:.2%}')
            ax1.axvline(x=terminal.u_optimal, color='orange', linestyle=':', alpha=0.7,
                        label=f'Cost Optimal = {terminal.u_optimal:.2%}')
            ax1.set_title('Total Revenue, Cost, and Profit')
            ax1.set_xlabel('V/C Ratio (Utilization)')
            ax1.set_ylabel('Total Value ($)')
            ax1.grid(True, linestyle='--', alpha=0.3)
            ax1.legend()

            # Plot 2: Marginal Functions
            ax2.plot(u_range, marginal_revenue_curve, label='Marginal Revenue', color='darkgreen', linewidth=2)
            ax2.plot(u_range, marginal_cost_curve, label='Marginal Cost', color='darkred', linewidth=2)
            ax2.axhline(y=0, color='black', linestyle='-', alpha=0.3)
            ax2.axvline(x=optimal_profit_vc, color='black', linestyle='--', alpha=0.7)
            ax2.axvline(x=terminal.u_optimal, color='orange', linestyle=':', alpha=0.7)
            ax2.set_title('Marginal Revenue and Cost')
            ax2.set_xlabel('V/C Ratio (Utilization)')
            ax2.set_ylabel('Marginal Value ($/TEU)')
            ax2.grid(True, linestyle='--', alpha=0.3)
            ax2.legend()

            # Plot 3: Per-Container Functions
            ax3.plot(u_range, revenue_per_container_curve, label='Revenue per TEU', color='green', linewidth=2)
            ax3.plot(u_range, average_cost_curve, label='Average Cost per TEU', color='red', linewidth=2)
            profit_per_container_curve = revenue_per_container_curve - average_cost_curve
            ax3.plot(u_range, profit_per_container_curve, label='Profit per TEU', color='blue', linewidth=2)
            ax3.axvline(x=optimal_profit_vc, color='black', linestyle='--', alpha=0.7)
            ax3.axvline(x=terminal.u_optimal, color='orange', linestyle=':', alpha=0.7)
            ax3.set_title('Per-Container Values')
            ax3.set_xlabel('V/C Ratio (Utilization)')
            ax3.set_ylabel('Value per TEU ($)')
            ax3.grid(True, linestyle='--', alpha=0.3)
            ax3.legend()

            # Plot 4: Terminal Information Summary
            ax4.axis('off')
            info_text = f"""
Terminal Parameters:
• Capacity: {capacity:,.0f} TEU/week
• Optimal Utilization: {terminal.u_optimal:.1%}
• Actual Profit Optimal: {optimal_profit_vc:.1%}

Revenue Function:
• Slope (a): {terminal.a:.2f} $/TEU per VC point
• Intercept (b): {terminal.b:.2f} $/TEU
• At 50% util: ${terminal.revenue_per_container(0.5):.2f}/TEU

Cost Function:
• Initial MC: ${terminal.mc_start:.2f}/TEU  
• Minimum MC: ${terminal.mc_min:.2f}/TEU
• Phase 1 slope: -{terminal.slope1:.2f}
• Phase 2 slope: +{terminal.slope2:.2f}

Performance at Optimal:
• Volume: {optimal_profit_vc * capacity:,.0f} TEU/week
• Max Profit: ${total_profit_curve[np.argmax(total_profit_curve)]:,.0f}/week
• Revenue/TEU: ${terminal.revenue_per_container(optimal_profit_vc):.2f}
• Cost/TEU: ${terminal.average_cost_per_container(optimal_profit_vc):.2f}
• Profit/TEU: ${terminal.profit_per_container(optimal_profit_vc):.2f}
            """
            ax4.text(0.05, 0.95, info_text, transform=ax4.transAxes, fontsize=10,
                     verticalalignment='top', fontfamily='monospace',
                     bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgray', alpha=0.8))

            plt.tight_layout()

            # Save plot
            plot_filename = f'{terminal_name}_analysis_CI0.png'
            plot_path = os.path.join(PLOT_OUTPUT_FOLDER, plot_filename)
            plt.savefig(plot_path, dpi=300, bbox_inches='tight')
            plt.close(fig)

            plots_created += 1
            if plots_created % 10 == 0:
                print(f"  Created {plots_created}/{total_terminals} plots...")

        except Exception as e:
            print(f"Error creating plot for terminal {terminal_name}: {e}")
            continue

    print(f"Individual terminal plotting complete!")
    print(f"  Total plots created: {plots_created}")
    print(f"  Saved to: {PLOT_OUTPUT_FOLDER}")


def save_analysis_to_excel(results_df: pd.DataFrame, sheet_name: str):
    """
    Saves the analysis results to a new Excel file.
    """
    if results_df.empty:
        print("No results to save.")
        return

    os.makedirs(OUTPUT_SUBFOLDER, exist_ok=True)

    try:
        with pd.ExcelWriter(OUTPUT_FILE, engine='openpyxl') as writer:
            results_df.to_excel(writer, sheet_name=sheet_name, index=False)
        print(f"\nAnalysis results saved to '{OUTPUT_FILE}' in sheet '{sheet_name}'.")
    except Exception as e:
        print(f"\nError saving to Excel: {e}")


def print_analysis_table(results_df: pd.DataFrame, title: str):
    """
    Prints a formatted summary table of the analysis results to the console.
    """
    if results_df.empty:
        print("No results to display.")
        return

    print("\n" + "=" * 135)
    print(f"{title} (CI Rate = {FILTER_CI_RATE:.0%} only)")
    print("=" * 135)

    # Show summary statistics
    print(f"Total terminals analyzed: {len(results_df)}")
    print(f"Terminal distributions:")
    terminal_counts = results_df.groupby(['Num_Terminals', 'Subset_Composition']).size()
    for (num_term, subset), count in terminal_counts.items():
        print(f"  {num_term} terminals, subset {subset}: {count} terminals")

    print("\nFirst few terminals:")
    print(results_df[['Filename', 'Terminal_ID', 'Optimal_Profit_VC_Ratio',
                      'Max_Total_Profit ($)', 'Capacity']].head(10).to_string(index=False))

    print("\nLast few terminals:")
    print(results_df[['Filename', 'Terminal_ID', 'Optimal_Profit_VC_Ratio',
                      'Max_Total_Profit ($)', 'Capacity']].tail(5).to_string(index=False))

    print("=" * 135)


if __name__ == "__main__":
    os.makedirs(OUTPUT_SUBFOLDER, exist_ok=True)
    print("=" * 80)
    print("MODIFIED DATA ACCURACY ANALYSIS - CI RATE = 0 ONLY")
    print("=" * 80)

    print(f"Filter settings:")
    print(f"  CI Rate filter: {FILTER_CI_RATE:.0%}")
    print(f"  Individual plots: Enabled")
    print(f"  Data folder: {DATA_FOLDER}")
    print(f"  Output folder: {OUTPUT_SUBFOLDER}")

    full_optimization_results = analyze_generated_data_from_folder(DATA_FOLDER)

    if not full_optimization_results.empty:
        print_analysis_table(full_optimization_results, "CI=0 TERMINALS ANALYSIS")

        # Create individual plots for each terminal
        plot_individual_terminal_functions(full_optimization_results)

        # Save to Excel
        save_analysis_to_excel(full_optimization_results, 'CI_Zero_Terminals_Analysis')

        print(f"\nSummary:")
        print(f"  Terminals analyzed: {len(full_optimization_results)}")
        print(f"  Individual plots created: {len(full_optimization_results)}")
        print(f"  All plots saved to: {PLOT_OUTPUT_FOLDER}")
    else:
        print("No terminals found with CI rate = 0. Check your data generation settings.")

    print("\nAnalysis process complete.")
    print("=" * 80)